-- 오라클 EQUL JOIN, 등가 조인
SELECT
    empno,
    ename,
    e.deptno,
    dname
FROM
    emp   e,
    dept  d
WHERE
        e.deptno = d.deptno
    AND empno > 7600
ORDER BY
    deptno,
    empno;
-- 조인 조건

--ANSI, INNER JOIN, 내부조인
SELECT
    EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E
INNER JOIN DEPT D
    ON E. DEPTNO = D.DEPTNO-- 조인조건
WHERE EMPNO > 7600    -- 일반 조회조건
ORDER BY DEPTNO, EMPNO;


SELECT ENAME, EMPNO, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

--NON-EQUI JOIN 비등가 조인
SELECT * FROM EMP; --사원테이블
SELECT * FROM SALGRADE; --급여등급 테이블

SELECT ENAME, SAL, GRADE
FROM EMP, SALGRADE --조인
WHERE SAL BETWEEN LOSAL AND HISAL -- 조인 조건
ORDER BY GRADE, SAL, ENAME;

-- 위의 코드와 같은 코드
SELECT ENAME, SAL, GRADE
FROM EMP 
INNER JOIN SALGRADE --조인
ON SAL BETWEEN LOSAL AND HISAL -- 조인 조건
ORDER BY GRADE, SAL, ENAME;


--SELF JOIN, 자체조인
SELECT * FROM EMP EMPLOYEE;
SELECT * FROM EMP MANAGER;

SELECT
    E.EMPNO, E.ENAME, E.MGR, M.ENAME "MGRNAME"
FROM EMP E, EMP M -- E 사원 M 매니저
WHERE E.MGR = M.EMPNO
ORDER BY E.EMPNO;

SELECT
    E.EMPNO, E.ENAME, E.MGR, M.ENAME "MGRNAME"
FROM EMP E
INNER JOIN EMP M -- E 사원 M 매니저
ON E.MGR = M.EMPNO
ORDER BY E.EMPNO;


--CROSS JOIN
SELECT * FROM EMP CROSS JOIN DEPT;
SELECT * FROM EMP , DEPT;


--NATURAL JOIN
SELECT *
FROM EMP
NATURAL JOIN DEPT
ORDER BY DEPTNO, EMPNO;

--OUTER JOIN, 외부 조인
SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT DISTINCT DEPTNO FROM EMP;

SELECT EMP.DEPTNO, DEPT.DEPTNO FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO (+)
ORDER BY EMP.DEPTNO;

-- (+) : OUTER JOIN 연산자
SELECT * FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO (+)
ORDER BY EMP.DEPTNO;

SELECT * FROM EMP, DEPT
WHERE EMP.DEPTNO (+) = DEPT.DEPTNO 
ORDER BY EMP.DEPTNO;


--오라클 전용구문을 이용한 외부조인
SELECT EMPNO,ENAME, D.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY DEPTNO, EMPNO;

--위랑 아래랑 같다.
--ANSI 전용구문을 이용한 외부조인
SELECT EMPNO,ENAME, D.DEPTNO, DNAME
FROM EMP E
RIGHT OUTER JOIN DEPT D 
ON E.DEPTNO  = D.DEPTNO
ORDER BY DEPTNO, EMPNO;


--오라클 전용구문을 이용한 외부조인
SELECT EMPNO,ENAME, D.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO(+)
ORDER BY DEPTNO, EMPNO;

--위랑 아래랑 같다.
--ANSI 전용구문을 이용한 외부조인
SELECT EMPNO,ENAME, D.DEPTNO, DNAME
FROM EMP E
LEFT OUTER JOIN DEPT D 
ON E.DEPTNO  = D.DEPTNO
ORDER BY DEPTNO, EMPNO;


--FULL OUTER JOIN
-- 오라클 전용구문으로 없음, ANSI 표준구문만 존재
-- 양쪽 테이블 데이터 모두 추가한다.
SELECT EMPNO,ENAME, D.DEPTNO, DNAME
FROM EMP E
FULL OUTER JOIN DEPT D 
ON E.DEPTNO  = D.DEPTNO
ORDER BY DEPTNO, EMPNO;


-- 서브쿼리, SUBQUERY

--KING의 부서번호 조회
SELECT DEPTNO FROM EMP
WHERE ENAME = 'KING';

-- 10번 부서의 정보 조회
SELECT * FROM DEPT
WHERE DEPTNO = 10;

--JOIN 을 이용한 해결
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D. DEPTNO -- 조인조건
AND ENAME = 'KING';

--SUBQUERY를 이용한 해결
SELECT * FROM DEPT
WHERE DEPTNO = (
    SELECT DEPTNO FROM EMP
    WHERE ENAME = 'KING');

-- 평균 임금보다 급여가 많이 사원 조회하기
-- 평균 그룹함수
-- WHERE절에 그룹함수 사용할 수 없다.
SELECT * FROM EMP
WHERE SAL > AVG(SAL);

--GROUP BY 절이 없으면 HAVING 사용불가
SELECT * FROM EMP
HAVING SAL> AVG(SAL);

--SUBQUERY를 이용한 해결
SELECT EMPNO, ENAME, SAL , 
ROUND((SELECT AVG(SAL) FROM EMP), 2) AS "AVG"
--(SELECT ROUND(AVG(SAL), 2) FROM EMP) AS "AVG"
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP);


-- 전체 평균 임금보다 부서별 평균임금이 높은 부서
--deptno, avg_sal 을 조회한다.
SELECT DEPTNO, 
ROUND( AVG(SAL), 2) AS "AVG_SAL" FROM EMP
GROUP BY DEPTNO
HAVING AVG(SAL) >(SELECT AVG(SAL) FROM EMP)
ORDER BY DEPTNO; 

-- 인라인 뷰, INLINE VIEW
-- 서브쿼리를 FROM 절에서 사용하기
SELECT * FROM EMP;

SELECT * FROM( -- 메인쿼리
    SELECT EMPNO, ENAME FROM EMP -- 서브쿼리
    );

SELECT EMPNO FROM( -- 메인쿼리( 서브쿼리에 있는 속성만 조회가능)
    SELECT EMPNO, ENAME FROM EMP -- 서브쿼리
    );
    
    
-- 30번 부서의 전체 사원 조회
SELECT * FROM EMP WHERE DEPTNO = 30;

--30번 부서의 전체 인원수 조회
SELECT COUNT(*) FROM(
SELECT * FROM EMP WHERE DEPTNO = 30
) E;

--30번 부서의 직무별 인원수 조회
SELECT JOB, COUNT(*) FROM(
    SELECT * FROM EMP WHERE DEPTNO = 30) CNT
GROUP BY JOB;

SELECT E.DEPTNO, DNAME, AVG_SAL FROM(
SELECT DEPTNO, 
ROUND( AVG(SAL), 2) AS "AVG_SAL" FROM EMP
GROUP BY DEPTNO
HAVING AVG(SAL) >(SELECT AVG(SAL) FROM EMP)
ORDER BY DEPTNO
) E, DEPT D
WHERE E.DEPTNO = D.DEPTNO; 

SELECT E.DEPTNO, DNAME, AVG_SAL FROM(
SELECT DEPTNO, 
ROUND( AVG(SAL), 2) AS "AVG_SAL" FROM EMP
GROUP BY DEPTNO
HAVING AVG(SAL) >(SELECT AVG(SAL) FROM EMP)
ORDER BY DEPTNO) E
INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


-- 스칼라 서브쿼리
-- SELECT절의 컬럼으로 서브쿼리를 사용하는 것
SELECT ENAME, EMPNO, DEPTNO
, (SELECT DNAME FROM DEPT D WHERE D.DEPTNO = E.DEPTNO) AS DNAME
FROM EMP E;

-- 상호 연관 서브쿼리(상관쿼리)
-- 메인쿼리와 서브쿼리의 관계를 이용해서 데이터가
-- 조회되는 것
-- 메인쿼리의 조회테이블과 서브쿼리의 조회테이블이 연관을
-- 가지도록 조건을 부여한다.

--QUIZ 부서별 인원 구하기
SELECT * FROM DEPT;
-- JOIN 이용방법
SELECT D.DEPTNO,  d.dname, COUNT(E.DEPTNO) AS CNT_EMPLOYEE
FROM EMP E
RIGHT OUTER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME
ORDER BY DEPTNO;


SELECT D.DEPTNO,  d.dname, COUNT(E.DEPTNO) AS CNT_EMPLOYEE
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME
ORDER BY DEPTNO;


